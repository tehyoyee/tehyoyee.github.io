---
layout: single
title: "fork; create child process"
categories: process
tag: 42seoul, C, Linux, fork, wait
toc: true
author_profile: false
sidebar:
 nav: "docs"
---

### fork
```c
#include <unistd.h>

pid_t fork(void);
```
현재의 프로세스를 복제하여 새로운 프로세스를 생성.<br>
새로운 프로세스는 child process 라고 부름.<br><br>

### wait
```c
pid_t	wait(int *wstatus);
```
자식 프로세스가 종료될 때까지 대기.<br>

반환 : 종료된 자식 프로세스의 pid

wstatus에는 자식 프로세스의 반환값이 저장되는데,<br>
정상종료시 최하위 8비트를 제외한 그 다음 bit에 내용이 저장된다.<br>
고로, 정상종료시 `wstatus >> 8`을 실행해야 반환값을 얻을 수 있다.<br>
비정상 종료시에는 최하위 8비트(1byte)에 종료값이 저장된다.<br>
8비트에 저장이 되기 때문에 반환값이 8비트보다 크면 overflow가 발생하는 것을 볼 수 있다.<br>
<br>
\<example>
```c
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int	main(void)
{
	int	wstatus;
	pid_t	pid;
	pid_t	pid_child;

	pid = fork();
	if (pid == -1)
	{
		printf("자식 프로세스 생성 실패.\n");
		return (-1);
	}
	else if (pid == 0)
	{
		printf("자식 프로세스 : 3초 카운트.\n");
		for (int i = 0; i < 3; i++)
		{
			printf("%d\n", i);
			sleep(1);
		}
		return(15);
	}
	else
	{
		printf("부모프로세스 : 자식 프로세스가 끝날 때까지 대기.\n");
		pid_child = wait(&wstatus);
		printf("자식 프로세스 종료.\n");
		printf("자식 프로세스 pid = %d ,   반환값 = %d\n", pid_child, wstatus >> 8);
		printf("부모 프로세스 시작.\n");
		for (int i = 0; i < 3; i++)
		{
			printf("%d\n", i);
			sleep(1);
		}
	}
}
```

